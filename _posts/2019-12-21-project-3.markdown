---
layout: default
modal-id: 3
date: 2019-12-21
img: youbot.gif
alt: image-alt
project-date: December 2019
description: <h2> Brief Overview</h2>  As the final project for the course on Robotic Manipulation, I implemented a PI feedforward controller for a 4 wheeled mobile robot with a 5 dof arm for an object manipulation task. The arm has 5 degrees of freedom and the wheels add 4 degrees of freedom making this a redundant robot with 9 degrees of freedom. The PI feed forward controller contains three terms $$ V(t) = [Ad_{X^{-1}X_d}] V_d(t) + K_{p} X_{err}(t) + K_{i} \int_{0}^{t} X_{err}(t) dt.$$<ul> <li> The feed forward term \([Ad_{X^{-1}X_d}] V_d(t)\)  which generates the twist for following a desired trajectory. (V_d is the twist required to take current desired end effector configuration to the next desired end effector configuration and is given by \([V_d] = (1 / \Delta t) log(X_d^{-1} X_{d, next})\) . This twist is then converted from the current desired end endeffector frame to the actual current end effector frame</li> <li> An error term which react to the error of the end effector \(K_{p} X_{err}(t)\) (the twist required to take the current end effector configuration to a desired end effector configuration at the current time step) </li> <li> An integral term which keeps a running sum of the errors accumulated so far.\(K_{i} \int_{0}^{t} X_{err}(t) dt\) ( summation of the error twists over time )</li> </ul> The output twist obtained by summing all three terms is then converted to robot velocity commands by using the Jacobian matrix associated with the 9D robot. \(\begin{pmatrix} u \\ \dot{\theta} \end{pmatrix} = J_e^{+} V.\)<br><br> Then the robot configuration is estimated by the applying the command velocities through the kinematic model of youbot.  <h2> A few observations</h2> The kerms Kp and Ki control how the system behaves <ul> <li> A high value of Kp brings down the errors rapidly width="400".</li> <li> A low value of Kp just makes the system’s response to errors slower.</li> <li> But a very high value of Kp causes jerky motion in the robot. </li>  <li> Ki is helpful for tracking problems for achieving absolute and quick convergence to the desired values but they sometimes induce oscillations and overshoots. Hence, this value is kept very low. </li> </ul>  <h2> Some minor algo details.</h2> For this problem, I needed to set wheel radius to 1.5 times of the normal wheel radius ( 1.5 * 0.0475 = 0.07125m ) to achieve a satisfactory grasping. A kp value of 1.5 and ki value of 0 was found to give satisfactory results and drove the errors to zero quickly without inducing overshoots.<br><br> <img src="./img/portfolio/youbot_error.png" class="center" width="560"> <br><br> When the same kp values were tried for the new tasks, the video looked good and the error graph looked almost similar. <div style="display:flex"> <div style="flex:1;padding-right:5px;"> <img src="./img/portfolio/youbot_newtask.png" width="560" class="left"> </div> <div style="flex:1;padding-left:5px;"> <iframe width="560" height="315" src="https://www.youtube.com/embed/FF0jhb3Z0xs" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> </div> </div> If very higher Ki values are used, overshoots were observed and in some cases the error didn't converge to zero before pickup and hence the pikcup failed. When \(K_i\) value of 0.25 and \(K_p\) value of 1.0 was used, the following error pattern and manipulation behavior was observed.<div style="display:flex"> <div style="flex:1;padding-right:5px;"> <img src="./img/portfolio/youbot_overshoot.png" width="560" class="left"> </div> <div style="flex:1;padding-left:5px;"> <iframe width="560" height="315" src="https://www.youtube.com/embed/KiBffqOmgKQ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>> </div> </div><br><br> <h2> Joint Limits </h2> Sometimes the robot involves in self collision like some in the video below. <iframe width="560" height="315" src="https://www.youtube.com/embed/Fl1smOTt_Xw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe> <br><br> To avoid this, I also implemented joint limits  so that self collisions are avoided. I also implemented singularity checks so that the arm configuration never goes near singulairy. The limits identified for the joints to achieve this objective were as follows<ul><li> \(\theta_1\) should be between -1.65 to 1.65 ( this limits avoid the arm to go and hit the back of the body or its sides)</li> <li> \(\theta_2\) should be less than -0.85 (This limit ensures that the arm is stretched out and hence reduces chances of collision) </li> <li> \(\theta_3\) and \(\theta_4\) are constrained to be less than -0.2 so that the arm doesn’t get close to a singularity.</li></ul> The robot was able to do good pickup with these limits but I did notice slow convergence of errors and sometimes, very small residual errors remained. This should be because my joint limit values should have been a touch conservative, which explains constant but very small errors. The video showing outputs of joint limits in action is shown below <iframe width="560" height="315" src="https://www.youtube.com/embed/WWke3m4Hq_g" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe><br><br> This video clearly shows that robot avoids self collision using the joint limits yet performs useful pick and place activities.<br><br> Due to copyright issues, the code of this project cannot be shared in public. If you like to discuss anything on the implementation, feel free to contact me.
title: Object Manipulation using Youbot in Simulation. 

---
